# 인증 및 권한 부여
인증이란 어떤 것이 참인지 확인하는 프로세스나 동작을 의미한다.   
권한 부여란 사용자와 관련된 접근 권한이나 정책을 지정하는 기능이다.

# 암호 해싱
해시는 단방향 암호다.
데이터를 암호화하는 대신 해시를 사용하는 이유는 다음과 같다.
1. 해시에는 키가 필요하지 않으므로 개인 키를 잃어버릴 염려가 없고, 원래 값으로 되돌릴 필요가 없는 값을 저장하는데 적합하다.
2. 암호해싱은 보안을 위한 완벽한 접근 방법이다.

### 약간의 조미료 더하기
해시 자체로도 적절한 보안 수준을 제공할 수 있지만 솔트와 페퍼를 더해 보안 수준을 올린다.
- [비밀번호 해시에 소금치기-바르게 쓰기](http://starplatina.tistory.com/entry/%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%ED%95%B4%EC%8B%9C%EC%97%90-%EC%86%8C%EA%B8%88%EC%B9%98%EA%B8%B0-%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%93%B0%EA%B8%B0)

### 사전 공격
사전은 이전에 공격당했던 암호 데이터베이스에서 파생되는 경우가 많으며, 사람은 예측 가능하기 때문에 종종 같은 암호를 사용하곤 한다.

### 페퍼 추가
최근 사용자에게 비밀번호의 최소 길이, 대소문자 조합, 특수 문자 추가 등을 요구하지만 암호가 복잡해지면 유용성이 떨어진다. 이 때, 페퍼를 추가하면 공격자의 속도를 늦추는데 도움이 된다.  
시스템은 페퍼 값을 알고 있지만 이것을 암호 및 솔트와 함께 저장해 두지 않는다. 페퍼는 애플리케이션 코드에 하드 코딩에 실행 설정으로 저장하거나 런타임에 접근하는  보안저장소에 저장할 수 있다. 따라서, 데이터베이스 테이블을 침해하는ㄴ데 성공했다하더라도 페퍼값을 모르기 때문에 데이터베이스가 쓸모가 없게된다.   
물론 공격자가 페퍼값을 찾을 수도 있다. 하지만 보안상의 거의 모든 부분은 해킹을 쉽게 하지못하도록 보안 수준을 올리거나 시간을 늦추기 위한 것으로 페퍼추가가 분명 의미가 있다.

### bcrypt
bycrypt는 몇 번의 라운드를 반복해 해시를 생성한다. 이로 인해 해시 생성 속도는 물론 무차별 대입 공격의 속도도 늦춰지므로 암호를 보호하는 안전한 방법이지만 느리다는 것이 특징이다.

### 벤치마크
해시된 문자열을 생성하고 비교하는데  걸리는 대략적인 시간을 보여준다.   
해시를 페퍼 목록 1000개와 비교하는데 걸리는 시간이 약 1.5ms이다. 짧은 시간처럼  보이지만 실제 서버가 여러 요청을 동시에 처리하므로 하나의 연산이 이 정도 걸린다는 것을 염두에 두어야한다.   
이 정보를 바탕으로 ***보안과 속도*** 라는 양쪽 측면에서 서비스의 균형을 맞출 수 있다. 그러나 항사아 속도보다는 **안전** 을 중시해야한다.
-  [페이스북: 암호  해싱 및 인증](https://video.adm.ntnu.no/pres/54b660049af94)

# JWT
JSON 웹 토큰(JWT)은 특정 환경에 있는 사용자의 권한 요청이나 데이터를 안전하게 전달하는 표준이다.
JWT에는 다음 두 가지 장점이 있다.
1. 권한 요청에 대한 표준 형식이므로 신뢰할 수 있는 프레임워크에서 사용할 수 있다.
2. 비대칭 암호화를 사용한다.

>비대칭 암호화를 사용한다는 것은?     
> 토큰이 서명되어있으므로 서명자의 공개키 만으로 수신자는 토큰이 신뢰할 수 있는 출처에서 왔는 지 확인할 수 있고, 이를 통해 인증 서버의 개인 키에 대한 불필요한 접근을 막을 수 있다.

- [JWT 공식 사이트](https://jwt.io/)
- [JSON Web Token 소개 및 구조](https://velopert.com/2389)

### JWT의 형식
JWT는 Base64-URL로 인코딩 되는 세 부분으로 나뉜다.
- Header:  암호화된 객체의 타입과 암호 서명을 위한 알고리즘을 결정한다.
- Payload: 토큰과 관련된 클레임의 세부사항을 포함하고 있다.
- Signature

>Signature  
서명의 형식은 공유 비밀 키를 사용하는 대칭방식(HS256)이나 공개 키/비밀키를  사용하는 비대칭 방식(RS256) 모두 가능하다. JWT의 경우 가장 좋은 옵션은 서비스에서  JWT를 인증해야 하는 비대칭 방식이며, 이 방식은 공개 키만 있으면 된다.


# 보안 메세지
암호화된  메시지를 보내야할 때 가장 좋은 방법 중 하나는 **비대칭 암호화** 이다.    
단, 메시지가 이 암호화 메서드가 허용하는 최대 길이보다 짧아야한다.  
비대칭 암호화는 공개 키를 사용해 암호화할 수 있지만 복호화 시에는 개인 키를 사용해야한다.

# 공유 암호
공유 암호에는 **대칭 암호화** 를 사용한다. 대칭 암호화는 비대칭 암호화보다  더 빠르며 모든 크기의 메세지를 처리할 수 있다.   
이 방식은 상대적으로 제한 없이 사용 가능하지만 문제는 양쪽이 비밀 키를 공유해야하므로 이로 인해 양 당사자에게 키를 배포하는 문제가 발생한다.   
복화할 시에는 암호화의 반대로 동작하면된다. 이 때, 암호화에 쓰였던 동일한 난수값을 인자로 넣어야한다.

>[대칭 키/비대칭 키 설명1](http://crazia.tistory.com/entry/PKI-PKI-%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%EA%B0%84%EB%8B%A8-%EC%84%A4%EB%AA%85)   
>[대칭 암호화/ 비대칭 암호 설명2](http://brownbears.tistory.com/73)

# 대용량 메시지의 비대칭 암호화
비대칭 암호화는 메시지의 길이 제한이 있지만 보안상 대칭 암호화 방법보다 키 노출에 대해 안전하다.  
하지만 대용량 메시지를 비대칭 암호화 방법으로 암호화 하고 싶다면?  
일반적인 해결책은 무작위 키를 생성해 메시지를 대칭 키 방식으로 암호화한 다음, 이 키를 비대칭 키 방식으로 암호화해 양 측에 분배하는것이다.
이렇게 하면 개인 키의 소유자만 대칭키를 복호화할 수 있으며, 대칭 키를 복호화한 후에만 메시지를 복호화할 수 있다.
